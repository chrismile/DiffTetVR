/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2024, Christoph Neuhauser
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <cstring>

#include <Utils/File/Logfile.hpp>
#include <Utils/File/FileUtils.hpp>

#include "Tet/Loaders/LoadersUtil.hpp"
#include "VtkWriter.hpp"

void VtkWriter::initializeWriter(const std::string& _filename, bool _isBinaryVtk) {
    filename = _filename;
    if (sgl::FileUtils::get()->getFileExtension(filename) == "vtk") {
        filename = sgl::FileUtils::get()->removeExtension(filename);
    }
    isBinaryVtk = _isBinaryVtk;
}

void VtkWriter::writeNextTimeStep(
        const std::vector<uint32_t>& cellIndices,
        const glm::vec3* vertexPositions, const glm::vec3* vertexVectorData, int numPoints) {
    std::string vtkFilename = filename + "." + std::to_string(timeStepNumber) + ".vtk";
    FILE* file;
    if (isBinaryVtk) {
        file = fopen(vtkFilename.c_str(), "wb");
    } else {
        file = fopen(vtkFilename.c_str(), "w");
    }
    if (file == nullptr) {
        sgl::Logfile::get()->throwError("Error: Couldn't open file \"" + vtkFilename + "\" for writing.");
    }

    writeVtkHeader(file);
    writePointCoordinates(file, vertexPositions, numPoints);
    writeCells(file, cellIndices);
    fprintf(file, "POINT_DATA %i\n", numPoints);
    writePointDataVector(file, vertexVectorData, numPoints, "Gradient");
    fclose(file);
    timeStepNumber++;
}

void VtkWriter::writeVtkHeader(FILE* file) const {
    fprintf(file, "# vtk DataFile Version 2.0\n");
    fprintf(file, "Generated by DiffTetVR\n");
    if (isBinaryVtk) {
        fprintf(file, "BINARY\n");
    } else {
        fprintf(file, "ASCII\n");
    }
    fprintf(file, "DATASET UNSTRUCTURED_GRID\n");
}

void VtkWriter::writePointCoordinates(FILE* file, const glm::vec3* vertexPositions, int numPoints) const {
    fprintf(file, "POINTS %i float\n", numPoints);
    if (isBinaryVtk) {
        auto* pointDataVector = new float[numPoints * 3];
        memcpy(pointDataVector, vertexPositions, numPoints * sizeof(glm::vec3));
        swapEndianness(pointDataVector, numPoints * 3);
        fwrite(pointDataVector, sizeof(glm::vec3), numPoints, file);
        delete[] pointDataVector;
    } else {
        for (int i = 0; i < numPoints; i++) {
            const glm::vec3& pt = vertexPositions[i];
            fprintf(file, "%f %f %f\n", pt.x, pt.y, pt.z);
        }
    }
}

void VtkWriter::writeCells(FILE* file, const std::vector<uint32_t>& cellIndices) const {
    const int VTK_TET_TYPE = 10;
    const int numCells = int(cellIndices.size() / 4);

    fprintf(file, "CELLS %i %i\n", numCells, int(cellIndices.size()) + numCells);
    if (isBinaryVtk) {
        std::vector<int32_t> dataField(int(cellIndices.size()) + numCells);
        for (int i = 0; i < numCells; i++) {
            auto offset = size_t(i) * 4;
            auto offsetOut = size_t(i) * 5;
            dataField.at(offsetOut + 0) = 4;
            dataField.at(offsetOut + 1) = int(cellIndices.at(offset));
            dataField.at(offsetOut + 2) = int(cellIndices.at(offset + 1));
            dataField.at(offsetOut + 3) = int(cellIndices.at(offset + 2));
            dataField.at(offsetOut + 4) = int(cellIndices.at(offset + 3));
        }
        swapEndianness(dataField.data(), int(dataField.size()));
        fwrite(dataField.data(), sizeof(uint32_t), dataField.size(), file);
    } else {
        for (int i = 0; i < numCells; i++) {
            auto offset = size_t(i) * 4;
            uint32_t i0 = cellIndices.at(offset);
            uint32_t i1 = cellIndices.at(offset + 1);
            uint32_t i2 = cellIndices.at(offset + 2);
            uint32_t i3 = cellIndices.at(offset + 3);
            fprintf(file, "%i %i %i %i %i\n", 4, i0, i1, i2, i3);
        }
    }

    fprintf(file, "CELL_TYPES %i\n", numCells);
    if (isBinaryVtk) {
        std::vector<int32_t> cellTypeArray(numCells, VTK_TET_TYPE);
        swapEndianness(cellTypeArray.data(), int(cellTypeArray.size()));
        fwrite(cellTypeArray.data(), sizeof(int32_t), numCells, file);
    } else {
        for (int i = 0; i < numCells; i++) {
            fprintf(file, "%i\n", VTK_TET_TYPE);
        }
    }
}

void VtkWriter::writePointDataVector(
        FILE* file, const glm::vec3* vectorData, int numPoints, const std::string& vectorName) const {
    std::string header = "VECTORS " + vectorName + " float\n";
    fwrite(header.c_str(), sizeof(char), header.size(), file);

    if (isBinaryVtk) {
        auto* pointDataVector = new float[numPoints * 3];
        memcpy(pointDataVector, vectorData, numPoints * sizeof(glm::vec3));
        swapEndianness(pointDataVector, numPoints * 3);
        fwrite(pointDataVector, sizeof(glm::vec3), numPoints, file);
        delete[] pointDataVector;
    } else {
        for (int i = 0; i < numPoints; i++) {
            const glm::vec3& v = vectorData[i];
            fprintf(file, "%f %f %f\n", v.x, v.y, v.z);
        }
    }
}
